package KnapSack;

import java.util.*;

public class Knapsack_starter {
    static int[] values = new int[]{1, 2, 5, 6};
    static int[] weights = new int[]{2, 3, 4, 5};
    static int capacity = 10; // bag capacity

    public static void main(String[] args) {
        System.out.println("Recursive solution : " + recursive());
        System.out.println("-------------------------------------------------");
        System.out.println("\nDynamic Programming (DP) solution with table : " + dp());
        System.out.println("-------------------------------------------------");
        System.out.println("Set method solution : " + dpSet()); // TODO
    }

    private static int recursive() {
        // Recursive solution is not implemented
        return 1;
    }

    private static int dp() {
        int items = weights.length;
        int[][] dp = new int[items + 1][capacity + 1];

        // Build the table in bottom-up manner
        for (int i = 1; i <= items; i++) {
            int currWeight = weights[i - 1];
            for (int j = 1; j <= capacity; j++) {
                if (currWeight <= j) {
                    // Current item can be included:
                    // max(value if we don't include the item, value if we include the item)
                    dp[i][j] = Math.max(dp[i - 1][j],
                            dp[i - 1][j - currWeight] + values[i - 1]);
                } else {
                    // Current item can't be included
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        printTable(dp);
        return dp[items][capacity];
    }

    private static void printTable(int[][] dp) {
        System.out.println("\nDP Table (Rows: Items, Columns: Capacity):");

        // Print header row for capacities
        System.out.print("capacity");
        for (int j = 0; j < dp[0].length; j++) {
            System.out.printf("%5d", j);
        }
        System.out.println();
        System.out.println("-------------------------------------------------");

        // Print each row with a label
        for (int i = 0; i < dp.length; i++) {
            if (i == 0) {
                System.out.printf("NoItem: ");
            } else {
                System.out.printf("Item %d: ", i);
            }
            for (int j = 0; j < dp[i].length; j++) {
                System.out.printf("%5d", dp[i][j]);
            }
            System.out.println();
        }
    }

    /**
     * Uses a TreeMap to track (weight, value) states.
     * The key is the total weight and the value is the maximum achievable value for that weight.
     * We prune states that are dominated by better (lower weight, higher value) states.
     */
    private static int dpSet() {
        // dp map: key = current weight, value = maximum value achievable with that weight.
        TreeMap<Integer, Integer> dp = new TreeMap<>();
        dp.put(0, 0);

        for (int i = 0; i < weights.length; i++) {
            int w = weights[i];
            int v = values[i];
            // Temporary list to hold new states generated by adding the current item.
            List<int[]> newStates = new ArrayList<>();

            // Iterate over current states
            for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {
                int currWeight = entry.getKey();
                int currValue = entry.getValue();
                int newWeight = currWeight + w;
                if (newWeight <= capacity) {
                    int newValue = currValue + v;
                    newStates.add(new int[]{newWeight, newValue});
                }
            }

            // Merge new states into dp map, while pruning dominated states.
            for (int[] state : newStates) {
                int newWeight = state[0];
                int newValue = state[1];

                // If we already have a state with the same weight and a higher or equal value, skip this state.
                if (dp.containsKey(newWeight) && dp.get(newWeight) >= newValue) {
                    continue;
                }

                // Remove any states that are worse than the new state.
                List<Integer> keysToRemove = new ArrayList<>();
                for (Map.Entry<Integer, Integer> e : dp.tailMap(newWeight).entrySet()) {
                    if (e.getValue() <= newValue) {
                        keysToRemove.add(e.getKey());
                    }
                }
                for (int key : keysToRemove) {
                    dp.remove(key);
                }
                dp.put(newWeight, newValue);
            }
        }

        // The answer is the maximum value among all states.
        int maxValue = 0;
        for (int value : dp.values()) {
            maxValue = Math.max(maxValue, value);
        }
        return maxValue;
    }

}
